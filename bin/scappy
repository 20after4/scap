#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
  Heterogeneous deployment script
  Deploys MediaWiki code and configuration to a group of servers via rsync.

"""
import argparse
import contextlib
import fcntl
import imp
import logging
import os
import pipes
import random
import re
import socket
import struct
import subprocess
import tempfile
import time


class Stats:
    """A simple StatsD metric client."""

    def __init__(self, host, port):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.address = (host, port)

    def timing(self, name, milliseconds):
        """Report a timing measurement in milliseconds."""
        metric = '%s:%s|ms' % (name, int(round(milliseconds)))
        self.socket.sendto(metric.encode('utf-8'), self.address)

    def increment(self, name, value=1):
        """Increment a measurement."""
        metric = '%s:%s|c' % (name, value)
        self.socket.sendto(metric.encode('utf-8'), self.address)


class IRCSocketHandler(logging.Handler):
    """Log handler for logmsgbot on #wikimedia-operation."""

    def __init__(self, host, port, timeout=1.0):
        super(IRCSocketHandler, self).__init__()
        self.addr = (host, port)
        self.level = logging.INFO
        self.timeout = timeout

    def emit(self, record):
        message = '!log %s %s' % (os.getlogin(), record.getMessage())
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect(self.addr)
            sock.sendall(message.encode('utf-8'))
            sock.close()
        except (socket.timeout, socket.error, socket.gaierror):
            self.handleError(record)


log = logging.getLogger('scap')
log.setLevel(logging.DEBUG)
log.addHandler(IRCSocketHandler('neon.wikimedia.org', 9200))
log.addHandler(logging.StreamHandler())


def shell_map(mapping):
    """Convert a map to a string of space-separated KEY=VALUE pairs."""
    return ' '.join('%s=%s' % (k, pipes.quote(v)) for k, v in mapping.items())


def read_hosts(path):
    """Reads hosts from a file into a list. Blank lines and comments
    are ignored."""
    with open(os.path.join('/etc/dsh/group', path)) as hosts_file:
        return re.findall(r'^\w+', hosts_file.read(), re.MULTILINE)


def get_config():
    """Load environment variables from mw-deployment-vars.sh."""
    dep_env = imp.load_source('__env', '/usr/local/lib/mw-deployment-vars.sh')
    return {k: v for k, v in dep_env.__dict__.items() if k.startswith('MW_')}


@contextlib.contextmanager
def lock(filename):
    """Context manager. Acquires a file lock on entry, releases on exit."""
    with open(filename, 'w+') as lock_fd:
        fcntl.lockf(lock_fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
        try:
            yield
        finally:
            fcntl.lockf(lock_fd, fcntl.LOCK_UN)


def cdb_items(buf):
    """Iterates over CDB key/value pairs."""
    table_start, = struct.unpack_from('<L', buf)
    offset = 2048
    while offset < table_start:
        lengths = struct.unpack_from('<LL', buf, offset)
        offset += 8
        yield struct.unpack_from('%ds %ds' % lengths, buf, offset)
        offset += sum(lengths)


def get_branches(wikiversions_cdb_path):
    """Get the set of active branches from a wikiversions.cdb file."""
    with open(wikiversions_cdb_path, 'rb') as cdb_file:
        cdb = cdb_file.read()
        return {v for k, v in cdb_items(cdb) if k.startswith('ver:')}


def dsh(command, group, exports=None):
    """Run a command on multiple hosts via DSH."""
    if exports:
        command = '%s %s' % (shell_map(exports), command)
    group_file = os.path.join('/etc/dsh/group', group)
    return subprocess.call(['/usr/bin/dsh', '-F40', '-cM', '-f',
                            group_file, '-o', '-oSetupTimeout=10', '--',
                            command.strip()])


def check_syntax(*paths):
    """Run lint.php on `paths`; raise CalledProcessError if nonzero exit."""
    cmd = '/usr/bin/php -n -dextension=parsekit.so /usr/local/bin/lint.php'
    return subprocess.check_call(cmd.split() + list(paths))


def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description='Deploy MediaWiki')
    parser.add_argument('--only-active', action='store_true', default=False)
    parser.add_argument('message', nargs=argparse.REMAINDER)
    return parser.parse_args()


def scap():
    """Deploy MediaWiki code and configuration."""
    start = time.time()

    config = get_config()
    stats = Stats(config['MW_STATSD_HOST'], config['MW_STATSD_PORT'])

    args = parse_args()
    message = ' '.join(args.message) or '(no message)'
    env = {}
    if args.active:
        branches = get_branches('%(MW_COMMON)s/wikiversions.cdb' % config)
        env['MW_VERSIONS_SYNC'] = ' '.join(branches)

    with lock('/var/lock/scap'):
        log.info('started scap: %s', message)

        log.debug('Checking syntax')
        check_syntax('%(MW_COMMON_SOURCE)s/wmf-config' % config)
        check_syntax('%(MW_COMMON_SOURCE)s/multiversion' % config)

        # Update the current machine so that serialization works. Push
        # wikiversions.dat changes so mwversionsinuse, set-group-write,
        # and mwscript work with the right version of the files.
        subprocess.check_call('/usr/local/bin/sync-common')

        # Update list of extension message files and regenerate the
        # localisation cache.
        subprocess.check_call('/usr/local/bin/mw-update-l10n')

        log.debug('updating rsync proxies')
        dsh('/usr/local/bin/scap-1', 'scap-proxies', env)

        scap_proxies = read_hosts('scap-proxies')

        # Randomize the order of target machines.
        mediawiki_installation_hosts = read_hosts('mediawiki-installation')
        random.shuffle(mediawiki_installation_hosts)
        with tempfile.NamedTemporaryFile(delete=False, prefix='scap') as tmp:
            try:
                tmp.write('\n'.join(mediawiki_installation_hosts))
                tmp.flush()

                log.debug('copying code to Apaches')
                dsh('/usr/local/bin/scap-1 %s' % ' '.join(scap_proxies),
                    tmp.name, env)

                log.debug('rebuilding CDB files')
                dsh('/usr/local/bin/scap-rebuild-cdbs', tmp.name, env)
            finally:
                os.remove(tmp.name)

        log.debug('building wikiversions.cdb')
        subprocess.check_call('sync-wikiversions')

    duration = time.time() - start

    human_duration = '%02dm %02ds' % divmod(duration, 60)
    log.info('finished scap: %s (duration: %s)', message, human_duration)

    stats.increment('scap.scap')
    stats.timing('scap.scap', duration * 1000)


if __name__ == '__main__':
    assert 'SSH_AUTH_SOCK' in os.environ, 'scap requires SSH agent forwarding'
    scap()
